name: Terraform Plan and Apply (Azure) - Emergency Mode

on:
  repository_dispatch:
    types: [tfvars-changed]
    
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Branch name from the Terraform core repository'
        required: true
        type: string
        default: '2.1'
      variables_branch:
        description: 'Branch name from the Terraform variables repository'
        required: true
        type: string
        default: '2.1'
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options: 
          - dev
          - staging
          - prod
        default: 'dev'
      enable_genesis_gateway:
        description: 'Enable Application Gateway for Genesis frontend'
        required: false
        type: boolean
        default: true
      enable_grafana_gateway:
        description: 'Enable Application Gateway routing for Grafana'
        required: false
        type: boolean
        default: true
      apply_changes:
        description: 'Apply changes after successful plan'
        required: false
        type: boolean
        default: false

permissions:
  id-token: write
  contents: read
  pull-requests: write
      
jobs:  
  terraform:
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'repository_dispatch' &&
       github.event.client_payload.tf-lifecycle == 'plan-apply')
    defaults:
      run:
        working-directory: .
    env:
      TF_WORKING_DIR: 'terraform-configs' 
      TARGET_BRANCH: ${{ github.event_name == 'workflow_dispatch' && inputs.target_branch || github.event.client_payload.target_branch }}
      VARIABLES_BRANCH: ${{ github.event_name == 'workflow_dispatch' && inputs.variables_branch || github.event.client_payload.variables_branch || github.event.client_payload.target_branch || '2.1' }}
      ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
      AZURE_KEYVAULT_URL: ${{ vars.AZURE_KEYVAULT_URL }}
      TF_CLI_CONFIG_FILE: ""
      TF_INPUT: "false"
      TF_IN_AUTOMATION: "true"
      TF_CLOUD_ORGANIZATION: ""
      TF_WORKSPACE: ""
      TF_TOKEN_app_terraform_io: ""

    outputs: 
      cluster_name: ${{ steps.finalizer.outputs.cluster_name }}
      resource_group: ${{ steps.finalizer.outputs.resource_group }}
      application_gateway_ip: ${{ steps.finalizer.outputs.application_gateway_ip }}
      genesis_fqdn: ${{ steps.finalizer.outputs.genesis_fqdn }}
      grafana_fqdn: ${{ steps.finalizer.outputs.grafana_fqdn }}
      grafana_url: ${{ steps.finalizer.outputs.grafana_url }}

    steps: 
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
           version: 'v1.32.0'
          
      - name: Run Common Terraform Routines
        id: tf-routines
        uses: ./.github/actions/terraform-common
        with:
          core_repo: ${{ vars.TF_CORE_REPO }}
          config_repo: ${{ vars.TF_CONFIG_REPO }}
          target_branch: ${{ env.TARGET_BRANCH }}
          variables_branch: ${{ env.VARIABLES_BRANCH }}
          environment: ${{ env.ENVIRONMENT }}
          pat-token: ${{ secrets.GH_PAT }}
      
      - name: ğŸš¨ Emergency Terraform Auth Routine
        uses: ./.github/actions/terraform-auth
        with:
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform__version: '1.6.6'

      - name: Setup Genesis Secrets
        if: ${{ inputs.enable_genesis_gateway == true }}
        run: |
          echo "GENESIS_PAT_TOKEN=${{ secrets.GENESIS_PAT_TOKEN }}" >> $GITHUB_ENV
          echo "GENESIS_USER_ID=Harman-DTS" >> $GITHUB_ENV

      - name: Generate Cache key hash
        id: target-dir-hash
        run: |
          echo "hash_value=${{ hashFiles(format('{0}/*.tf', env.TF_WORKING_DIR)) }}" >> $GITHUB_OUTPUT

      - name: Restore Terraform cache
        id: restore-cache
        uses: actions/cache@v4
        with:
          key: ${{ runner.os }}-terraform-${{ env.TARGET_BRANCH }}-${{ steps.target-dir-hash.outputs.hash_value }}
          restore-keys: |
            ${{ runner.os }}-terraform-${{ env.TARGET_BRANCH  }}-
            ${{ runner.os }}-terraform-
          path: |
            ${{ env.TF_WORKING_DIR }}/.terraform.lock.hcl
            ${{ env.TF_WORKING_DIR }}/.terraform/

      - name: ğŸ’¥ Nuclear Reset - Complete Terraform Cloud Disable
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "ğŸ’¥ NUCLEAR RESET: Completely removing all Terraform Cloud traces..."
          
          # Remove ALL Terraform files and directories
          rm -rf .terraform/ 2>/dev/null || true
          rm -f .terraform.lock.hcl 2>/dev/null || true
          rm -f terraform.tfstate* 2>/dev/null || true
          rm -f .terraformrc 2>/dev/null || true
          rm -f terraform.rc 2>/dev/null || true
          
          # Remove global Terraform configurations
          rm -rf ~/.terraform.d/ 2>/dev/null || true
          rm -f ~/.terraformrc 2>/dev/null || true
          rm -f ~/terraform.rc 2>/dev/null || true
          
          # Create empty Terraform configuration directory
          mkdir -p ~/.terraform.d
          echo '{}' > ~/.terraform.d/credentials.tfrc.json
          
          # Create a clean versions.tf file with ONLY local backend
          cat > versions_clean.tf << 'EOF'
          terraform {
            required_providers {
              azurerm = {
                source  = "hashicorp/azurerm"
                version = ">= 4.20.0"
              }
              azuread = {
                source  = "hashicorp/azuread"
                version = ">= 3.0.0"
              }
              random = {
                source  = "hashicorp/random"
                version = "~> 3.5.1"
              }
              kubernetes = {
                source  = "hashicorp/kubernetes"
                version = ">= 2.10.0"
              }
              helm = {
                source  = "hashicorp/helm"
                version = ">= 2.5.0"
              }
            }
            required_version = ">= 1.5.0"

            backend "local" {
              path = "terraform.tfstate"
            }
          }
          EOF
          
          # Replace the original versions.tf
          cp versions_clean.tf versions.tf
          
          echo "âœ… Nuclear reset completed - all Terraform Cloud traces removed"
          
          # Verify the clean state
          echo "ğŸ“‹ Current versions.tf content:"
          cat versions.tf
          
          echo "ğŸ“‚ Current directory contents:"
          ls -la

      - name: Terraform Init (Fixed Local Backend)
        if: steps.restore-cache.outputs.cache-hit != 'true'
        run: |
          echo "ğŸ  Clean initialization with local backend..."
          
          # Double-check no cloud configuration exists
          if grep -q "cloud\|remote" versions.tf; then
            echo "âŒ Found cloud/remote configuration - cleaning..."
            sed -i '/cloud\|remote/d' versions.tf
          fi
          
          # Initialize with correct flags for local backend
          terraform init \
            -input=false \
            -force-copy \
            -get \
            -reconfigure
          
          echo "âœ… Terraform initialized with local backend"
          
          # Verify initialization
          terraform version
          ls -la .terraform/ || echo "No .terraform directory"
        working-directory: ${{ env.TF_WORKING_DIR }}
        
      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Plan
        id: plan
        run: |
          echo "ğŸ” Running Terraform Plan..."
          terraform plan -input=false -var-file="${{ env.ENVIRONMENT }}.tfvars" -out=tfplan
          terraform show -no-color tfplan > tfplan.txt
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Upload Plan Output
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: |
            ${{ env.TF_WORKING_DIR }}/tfplan
            ${{ env.TF_WORKING_DIR }}/tfplan.txt
          retention-days: 30

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const planOutput = fs.readFileSync('${{ env.TF_WORKING_DIR }}/tfplan.txt', 'utf8');
            
            const comment = `## ğŸ—ï¸ Terraform Plan Results for ${{ env.ENVIRONMENT }} (Emergency Mode)
            
            ### Core Branch: ${{ env.TARGET_BRANCH }}
            ### Variables Branch: ${{ env.VARIABLES_BRANCH }}
            ### Genesis Gateway: ${{ inputs.enable_genesis_gateway }}
            ### Grafana Gateway: ${{ inputs.enable_grafana_gateway }}
            
            <details>
            <summary>ğŸ“‹ Show Plan Details</summary>
            
            \`\`\`hcl
            ${planOutput}
            \`\`\`
            
            </details>
            
            ${planOutput.includes('Plan:') ? 'âœ… Plan generated successfully' : 'âš ï¸ No changes detected'}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Terraform Apply
        if: >
          (github.event_name == 'workflow_dispatch' && inputs.apply_changes == true) ||
          (github.event_name == 'repository_dispatch' && 
           github.event.client_payload.tf-lifecycle == 'plan-apply' && 
           github.event.client_payload.event_name != 'pull_request_target') ||
          (github.ref == 'refs/heads/main' && github.event_name == 'push')
        run: |
          echo "ğŸš€ Applying Terraform changes..."
          terraform apply -auto-approve tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Post-Apply Finalizations
        if: >
          (github.event_name == 'workflow_dispatch' && inputs.apply_changes == true) ||
          (github.event_name == 'repository_dispatch' && 
           github.event.client_payload.tf-lifecycle == 'plan-apply' && 
           github.event.client_payload.event_name != 'pull_request_target') ||
          (github.ref == 'refs/heads/main' && github.event_name == 'push')
        id: finalizer
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "ğŸ“Š Extracting Terraform outputs..."
          
          # Get cluster credentials if AKS exists
          if terraform output cluster_name &>/dev/null; then
            CLUSTER_NAME=$(terraform output -raw cluster_name)
            RESOURCE_GROUP=$(terraform output -raw resource_group_name)
            
            echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
            echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
            
            # Update kubeconfig
            az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --overwrite-existing
            echo "âœ… Kubeconfig updated for cluster: $CLUSTER_NAME"
          fi
          
          # Get Application Gateway info if enabled
          if [[ "${{ inputs.enable_genesis_gateway }}" == "true" ]] && terraform output application_gateway_public_ip &>/dev/null; then
            APP_GW_IP=$(terraform output -raw application_gateway_public_ip)
            GENESIS_FQDN="genesis-azure.d01.hdcss.com"
            echo "application_gateway_ip=$APP_GW_IP" >> $GITHUB_OUTPUT
            echo "genesis_fqdn=$GENESIS_FQDN" >> $GITHUB_OUTPUT
            echo "ğŸŒ Application Gateway IP: $APP_GW_IP"
            echo "ğŸ¯ Genesis FQDN: $GENESIS_FQDN"
          fi
          
          # Get Grafana information
          if terraform output grafana_url &>/dev/null; then
            GRAFANA_URL=$(terraform output -raw grafana_url)
            GRAFANA_FQDN="grafana.genesis-azure.d01.hdcss.com"
            echo "grafana_url=$GRAFANA_URL" >> $GITHUB_OUTPUT
            echo "grafana_fqdn=$GRAFANA_FQDN" >> $GITHUB_OUTPUT
            echo "ğŸ“Š Grafana URL: $GRAFANA_URL"
            echo "ğŸ¯ Grafana Custom FQDN: $GRAFANA_FQDN"
          fi

  genesis-argocd-setup:
    needs: terraform
    name: Genesis ArgoCD Configuration
    if: >
      inputs.enable_genesis_gateway == true &&
      ((github.event_name == 'workflow_dispatch' && inputs.apply_changes == true) ||
       (github.event_name == 'repository_dispatch' && 
        github.event.client_payload.tf-lifecycle == 'plan-apply' && 
        github.event.client_payload.event_name != 'pull_request_target') ||
       (github.ref == 'refs/heads/main' && github.event_name == 'push'))
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
    env:
      CLUSTER_NAME: ${{ needs.terraform.outputs.cluster_name }}
      RESOURCE_GROUP: ${{ needs.terraform.outputs.resource_group }}
      GENESIS_FQDN: ${{ needs.terraform.outputs.genesis_fqdn }}
      APP_GATEWAY_IP: ${{ needs.terraform.outputs.application_gateway_ip }}
      VARIABLES_BRANCH: ${{ github.event_name == 'workflow_dispatch' && inputs.variables_branch || github.event.client_payload.variables_branch || github.event.client_payload.target_branch || '2.1' }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Checkout Terraform Variables for ArgoCD
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.TF_CONFIG_REPO }}
          token: ${{ secrets.GH_PAT }}
          path: terraform-vars
          ref: ${{ env.VARIABLES_BRANCH }}
          
      - name: ğŸš¨ Emergency Azure Authentication
        uses: ./.github/actions/terraform-auth
        with:
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'

      - name: Update kubeconfig
        run: |
          az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }} --overwrite-existing

      - name: Setup Python and Dependencies
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install azure-keyvault-secrets azure-identity git+https://github.com/p1utoze/pyargocd.git

      - name: Setup Genesis Secrets in Key Vault
        run: |
          echo "ğŸ” Setting up Genesis secrets in Azure Key Vault..."
          
          # Store Genesis credentials in Key Vault
          az keyvault secret set \
            --vault-name oorja-dev-kv-bnk4ys \
            --name "genesis-username" \
            --value "Harman-DTS" || echo "âš ï¸ Key Vault access limited"
          
          az keyvault secret set \
            --vault-name oorja-dev-kv-bnk4ys \
            --name "genesis-password" \
            --value "${{ secrets.GENESIS_PAT_TOKEN }}" || echo "âš ï¸ Key Vault access limited"

      - name: Install ArgoCD CLI
        uses: ./.github/actions/setup-argocd-cli

      - name: Configure ArgoCD Access
        run: |
          echo "ğŸ¯ Configuring ArgoCD access..."
          
          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd || true
          
          # Get ArgoCD admin password
          ARGOCD_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Port forward to ArgoCD server
          kubectl port-forward svc/argocd-server -n argocd 8080:443 &
          sleep 10
          
          # Login to ArgoCD
          argocd login localhost:8080 --username admin --password $ARGOCD_PWD --insecure
          
          echo "âœ… ArgoCD access configured"

      - name: Deploy Genesis Projects via ArgoCD
        run: |
          echo "ğŸš€ Deploying Genesis applications via ArgoCD..."
          echo "ğŸ“‚ Using variables from branch: ${{ env.VARIABLES_BRANCH }}"
          
          # Set environment variables for template substitution
          export username="Harman-DTS"
          export password="${{ secrets.GENESIS_PAT_TOKEN }}"
          
          # Apply ArgoCD configurations from terraform-vars
          python scripts/argocd-project.py -f terraform-vars/manifests/argocd-configs/project.yaml
          python scripts/argocd-repository.py -f terraform-vars/manifests/argocd-configs/repository.yaml
          python scripts/argocd-application.py -f terraform-vars/manifests/argocd-configs/application.yaml

      - name: Verify Genesis Deployment
        run: |
          echo "ğŸ” Verifying Genesis deployment..."
          
          # Wait for Genesis applications to be healthy
          timeout 600 bash -c '
            while ! kubectl get pods -n genesis | grep -E "(frontend|backend|postgresql)" | grep -q "Running"; do
              echo "Waiting for Genesis pods to be ready..."
              sleep 30
            done
          '
          
          # Show Genesis services
          kubectl get svc -n genesis
          
          echo "ğŸ‰ Genesis is now accessible through Application Gateway!"
          echo "ğŸŒ Frontend URL: https://${{ env.GENESIS_FQDN }}"
          echo "ğŸ“¡ Application Gateway IP: ${{ env.APP_GATEWAY_IP }}"
  
  grafana-configuration:
    needs: terraform
    name: Grafana Dashboard Configuration
    if: >
      inputs.enable_grafana_gateway == true &&
      ((github.event_name == 'workflow_dispatch' && inputs.apply_changes == true) ||
       (github.event_name == 'repository_dispatch' && 
        github.event.client_payload.tf-lifecycle == 'plan-apply' && 
        github.event.client_payload.event_name != 'pull_request_target') ||
       (github.ref == 'refs/heads/main' && github.event_name == 'push'))
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
    env:
      CLUSTER_NAME: ${{ needs.terraform.outputs.cluster_name }}
      RESOURCE_GROUP: ${{ needs.terraform.outputs.resource_group }}
      GRAFANA_URL: ${{ needs.terraform.outputs.grafana_url }}
      GRAFANA_FQDN: ${{ needs.terraform.outputs.grafana_fqdn }}
      APP_GATEWAY_IP: ${{ needs.terraform.outputs.application_gateway_ip }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸš¨ Emergency Azure Authentication
        uses: ./.github/actions/terraform-auth
        with:
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.0'

      - name: Update kubeconfig
        run: |
          az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }} --overwrite-existing

      - name: Configure Grafana Datasources
        run: |
          echo "ğŸ“Š Configuring Grafana datasources..."
          
          # Get Grafana workspace information
          GRAFANA_ID=$(az grafana list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].id" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$GRAFANA_ID" ]; then
            echo "âœ… Found Grafana workspace: $GRAFANA_ID"
            
            # Configure Prometheus datasource
            echo "ğŸ”— Configuring Prometheus datasource..."
            
            # Get Prometheus service endpoint from cluster
            PROMETHEUS_URL="http://prometheus-server.observability.svc.cluster.local"
            
            # Note: Azure Managed Grafana datasource configuration
            # This would typically be done through Azure CLI or ARM templates
            echo "ğŸ“¡ Prometheus URL: $PROMETHEUS_URL"
            echo "ğŸ¯ Grafana will be accessible at: https://${{ env.GRAFANA_FQDN }}"
            echo "ğŸ“Š Native Grafana URL: ${{ env.GRAFANA_URL }}"
            
          else
            echo "âš ï¸ Grafana workspace not found in resource group (limited access)"
          fi

      - name: Verify Grafana Access
        run: |
          echo "ğŸ” Verifying Grafana configuration..."
          
          # Check if Grafana is accessible
          if [ -n "${{ env.GRAFANA_URL }}" ]; then
            echo "âœ… Azure Managed Grafana deployed successfully!"
            echo ""
            echo "ğŸ¯ Access URLs:"
            echo "  ğŸ“Š Native Azure Grafana: ${{ env.GRAFANA_URL }}"
            echo "  ğŸŒ Application Gateway: https://${{ env.GRAFANA_FQDN }}"
            echo "  ğŸ“¡ Application Gateway IP: ${{ env.APP_GATEWAY_IP }}"
            echo ""
            echo "ğŸ‘¤ Admin User: 299b42cc-b252-4e9e-bef2-f4c5370ebdca"
            echo ""
            echo "ğŸ”§ Next Steps:"
            echo "  1. Add DNS record: ${{ env.APP_GATEWAY_IP }} â†’ grafana.genesis-azure.d01.hdcss.com"
            echo "  2. Configure additional datasources in Grafana UI"
            echo "  3. Import dashboards for AKS monitoring"
          else
            echo "âš ï¸ Grafana URL not available from Terraform outputs"
          fi
