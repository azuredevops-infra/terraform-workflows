name: ArgoCD Apply By Service

on:
  repository_dispatch:
    types: [service-changed]
    
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Branch name from the Terraform core repository containing root module configurations (not from the workflows repository)'
        required: true
        type: string
      environment:
        description: 'Type of the deployment environment to use'
        required: true
        type: choice
        options: 
          - dev
          - staging
          - prod  
      service:
        description: 'Type of ARGOCD service to apply'
        type: choice
        options:
          - project
          - repository
          - application
      use_external_url:
        description: 'Use external ArgoCD URL instead of port-forward'
        type: boolean
        default: false  # Changed to false as default since external has path issues
        
permissions:
      id-token: write
      contents: read
      
jobs:  
  argocd:
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'repository_dispatch'
    defaults:
      run:
        working-directory: .
    env:
      TF_WORKING_DIR: 'terraform-configs' 
      TARGET_BRANCH: ${{ github.event_name == 'workflow_dispatch' && inputs.target_branch || github.event.client_payload.target_branch }}
      ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.event.client_payload.environment }}
      SERVICE: ${{ github.event_name == 'workflow_dispatch' && inputs.service || github.event.client_payload.service }}
      USE_EXTERNAL_URL: ${{ github.event_name == 'workflow_dispatch' && inputs.use_external_url || false }}
      ARGOCD_VERIFY_SSL: false
      ARGOCD_NAMESPACE: argocd
      ARGOCD_SERVICE_NAME: argocd-dev-server
      ARGOCD_EXTERNAL_HOST: genesis-azure.d01.hdcss.com
      ARGOCD_EXTERNAL_URL: https://genesis-azure.d01.hdcss.com
      CLUSTER_NAME: oorja-dev-aks
      RESOURCE_GROUP_NAME: oorja-dev-rg

    steps: 
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
           version: 'v1.32.0'
        id: install

      - name: Install kubelogin
        run: |
          echo "üì¶ Installing kubelogin for Azure AD authentication..."
          
          # Download and install kubelogin
          KUBELOGIN_VERSION="v0.0.32"
          curl -LO "https://github.com/Azure/kubelogin/releases/download/${KUBELOGIN_VERSION}/kubelogin-linux-amd64.zip"
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          sudo chmod +x /usr/local/bin/kubelogin
          
          # Verify installation
          kubelogin --version
          echo "‚úÖ kubelogin installed successfully"
          
      - name: Run Common Terraform Routines
        id: tf-routines
        uses: ./.github/actions/terraform-common
        with:
          core_repo: ${{ vars.TF_CORE_REPO }}
          config_repo: ${{ vars.TF_CONFIG_REPO }}
          target_branch: ${{ env.TARGET_BRANCH }}
          variables_branch: "2.1"
          environment: ${{ env.ENVIRONMENT }}
          pat-token: ${{ secrets.GH_PAT }}
      
      - name: Run Terraform Auth Routine
        uses: ./.github/actions/terraform-auth
        with:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Install ArgoCD CLI
        uses: ./.github/actions/setup-argocd-cli

      - name: Update AKS Kubeconfig with Admin Credentials
        run: |
          echo "üîç Getting AKS cluster credentials with admin access..."
          echo "Cluster: ${{ env.CLUSTER_NAME }}"
          echo "Resource Group: ${{ env.RESOURCE_GROUP_NAME }}"
          
          # Get AKS admin credentials (bypasses Azure AD RBAC)
          az aks get-credentials --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --admin --overwrite-existing
          
          # Test connection
          echo "üîó Testing cluster connection..."
          kubectl cluster-info --request-timeout=30s
          
          # Verify we can access namespaces
          echo "üìÇ Available namespaces:"
          kubectl get namespaces
          
          echo "‚úÖ Kubeconfig updated and verified successfully"
      - name: Verify ArgoCD Deployment
        run: |
          echo "üîç Checking ArgoCD deployment..."
          
          # Check ArgoCD namespace
          if ! kubectl get namespace ${{ env.ARGOCD_NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå ArgoCD namespace '${{ env.ARGOCD_NAMESPACE }}' not found"
            echo "üìÇ Available namespaces:"
            kubectl get namespaces
            exit 1
          fi
          
          # Check ArgoCD service
          if ! kubectl get service ${{ env.ARGOCD_SERVICE_NAME }} -n ${{ env.ARGOCD_NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå ArgoCD service '${{ env.ARGOCD_SERVICE_NAME }}' not found in namespace '${{ env.ARGOCD_NAMESPACE }}'"
            echo "üìã Available services:"
            kubectl get services -n ${{ env.ARGOCD_NAMESPACE }}
            exit 1
          fi
          
          # Check ArgoCD pods
          echo "üìã ArgoCD pods status:"
          kubectl get pods -n ${{ env.ARGOCD_NAMESPACE }}
          
          # Check ArgoCD ingress
          echo "üìã ArgoCD ingress:"
          kubectl get ingress -n ${{ env.ARGOCD_NAMESPACE }} || echo "No ingress found"
          
          # Get ArgoCD service details
          echo "üìã ArgoCD service details:"
          kubectl get service ${{ env.ARGOCD_SERVICE_NAME }} -n ${{ env.ARGOCD_NAMESPACE }} -o yaml | grep -A 10 -B 5 port || echo "Could not get service details"
          
          # Check if ArgoCD server is ready
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-server -n ${{ env.ARGOCD_NAMESPACE }} --timeout=60s || echo "‚ö†Ô∏è ArgoCD server may not be fully ready"
          
          echo "‚úÖ ArgoCD deployment verified"
      - name: Get ArgoCD Admin Password
        run: |
          echo "üîç Retrieving ArgoCD admin password..."
          
          # Get the admin password from the secret
          ADMIN_PASSWORD=$(kubectl -n ${{ env.ARGOCD_NAMESPACE }} get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d || echo "")
          
          if [ -z "$ADMIN_PASSWORD" ]; then
            echo "‚ùå Could not retrieve ArgoCD admin password"
            echo "üìã Available secrets in ${{ env.ARGOCD_NAMESPACE }} namespace:"
            kubectl get secrets -n ${{ env.ARGOCD_NAMESPACE }}
            echo ""
            echo "üîç Checking for alternative admin secrets..."
            kubectl get secrets -n ${{ env.ARGOCD_NAMESPACE }} | grep admin || echo "No admin secrets found"
            exit 1
          fi
          
          echo "::add-mask::$ADMIN_PASSWORD"
          echo "ARGOCD_ADMIN_PASSWORD=$ADMIN_PASSWORD" >> $GITHUB_ENV
          echo "‚úÖ Retrieved ArgoCD admin password"
          echo "Password length: ${#ADMIN_PASSWORD} characters"
      - name: Test External ArgoCD Access
        if: env.USE_EXTERNAL_URL == 'true'
        run: |
          echo "üîç Testing external ArgoCD access..."
          echo "üåê External URL: ${{ env.ARGOCD_EXTERNAL_URL }}"
          
          # Test different potential ArgoCD API endpoints
          echo "üîó Testing different API endpoints..."
          
          # Test root API
          echo "Testing: ${{ env.ARGOCD_EXTERNAL_URL }}/api/version"
          curl -k -s "${{ env.ARGOCD_EXTERNAL_URL }}/api/version" --max-time 10 || echo "‚ùå Root API not accessible"
          
          # Test admin path API  
          echo "Testing: ${{ env.ARGOCD_EXTERNAL_URL }}/admin/api/version"
          curl -k -s "${{ env.ARGOCD_EXTERNAL_URL }}/admin/api/version" --max-time 10 || echo "‚ùå Admin API not accessible"
          
          # Check what's actually at the root
          echo "Testing: ${{ env.ARGOCD_EXTERNAL_URL }}/"
          curl -k -I "${{ env.ARGOCD_EXTERNAL_URL }}/" --max-time 10
          
          echo "üîç Checking if ArgoCD API is accessible via external URL..."
      - name: Setup ArgoCD Connection (Enhanced Auth)
        run: |
          echo "üîç Setting up ArgoCD connection (Enhanced Auth)"

          # Use port-forward (since external URL has issues)
          echo "üîó Using port-forward to ArgoCD server..."

          # Start port-forward in background
          kubectl port-forward svc/${{ env.ARGOCD_SERVICE_NAME }} -n ${{ env.ARGOCD_NAMESPACE }} 8080:80 &
          PORT_FORWARD_PID=$!
          echo "PORT_FORWARD_PID=$PORT_FORWARD_PID" >> $GITHUB_ENV

          # Wait for port-forward to be ready
          echo "‚è≥ Waiting for port-forward to be ready..."
          sleep 20

          # Test connection multiple times
          echo "üîó Testing port-forward connection..."
          for i in {1..10}; do
            if curl -s http://localhost:8080/api/version >/dev/null 2>&1; then
              echo "‚úÖ Port-forward connection successful"
              break
            else
              echo "‚è≥ Attempt $i: Waiting for port-forward..."
              sleep 3
            fi
            if [ $i -eq 10 ]; then
              echo "‚ùå Port-forward connection failed after 10 attempts"
              exit 1
            fi
          done

           # Login using CLI with detailed debugging
          echo "üîë Logging in to ArgoCD via port-forward..."
          echo "Admin password length: ${#ARGOCD_ADMIN_PASSWORD}"

          # First, test if API is responding
          echo "Testing API endpoint..."
          curl -s http://localhost:8080/api/version || echo "API not responding"

          # Login with explicit options
          if argocd login localhost:8080 \
              --username admin \
              --password "${{ env.ARGOCD_ADMIN_PASSWORD }}" \
              --insecure \
              --grpc-web \
              --plaintext; then
            echo "‚úÖ ArgoCD CLI login successful"
          else
            echo "‚ùå ArgoCD CLI login failed"
            echo "Testing alternative login method..."
            echo "${{ env.ARGOCD_ADMIN_PASSWORD }}" | argocd login localhost:8080 \
              --username admin \
              --insecure \
              --grpc-web \
              --plaintext || {
              echo "‚ùå Alternative login method also failed"
              exit 1
            }
          fi

          # Generate token with more specific settings
          echo "üé´ Generating authentication token..."
          auth_token=$(argocd account generate-token \
            --account admin \
            --expires-in 30m \
            --grpc-web \
            --insecure 2>&1) || {
            echo "‚ùå Token generation failed"
            echo "Trying without grpc-web..."
            auth_token=$(argocd account generate-token \
              --account admin \
              --expires-in 30m \
              --insecure 2>&1) || {
              echo "‚ùå Token generation failed completely"
              exit 1
            }
          }

          # Validate token format
          if [[ "$auth_token" =~ ^[A-Za-z0-9+/].*$ ]] && [ ${#auth_token} -gt 20 ]; then
            echo "‚úÖ Token generated successfully"
            echo "Token length: ${#auth_token}"
            echo "Token prefix: ${auth_token:0:10}..."
            echo "::add-mask::$auth_token"
            echo "ARGOCD_AUTH_TOKEN=$auth_token" >> $GITHUB_ENV
            echo "ARGOCD_SERVER=localhost:8080" >> $GITHUB_ENV
            echo "ARGOCD_OPTS=--insecure --grpc-web" >> $GITHUB_ENV
          else
            echo "‚ùå Invalid token format received: $auth_token"
            exit 1
          fi

          # Test the token works with CLI
          echo "üß™ Testing token with CLI..."
          if argocd proj list --auth-token "$auth_token" --server localhost:8080 --insecure --grpc-web >/dev/null 2>&1; then
            echo "‚úÖ Token works with ArgoCD CLI"
          else
            echo "‚ö†Ô∏è Token test with CLI failed, but proceeding..."
          fi
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          echo "üì¶ Installing Python dependencies..."
          pip install -r requirements.txt git+https://github.com/p1utoze/pyargocd.git
          echo "‚úÖ Dependencies installed successfully"
      - name: Validate Service Input
        run: |
          echo "üîç Validating service input: ${{ env.SERVICE }}"
          if [[ ! "${{ env.SERVICE }}" =~ ^(project|repository|application)$ ]]; then
            echo "‚ùå Invalid 'service' input: ${{ env.SERVICE }}"
            echo "Valid options: project, repository, application"
            exit 1
          fi
          echo "‚úÖ Service input validation passed"
      - name: Setup Environment for Python Scripts
        run: |
          echo "üîß Setting up environment for Python scripts..."
          
          # Set ArgoCD server URL for Python scripts based on what worked for CLI
          if [ "${{ env.ARGOCD_SERVER }}" = "localhost:8080" ]; then
            echo "ARGOCD_URL=http://localhost:8080" >> $GITHUB_ENV
            export ARGOCD_URL="http://localhost:8080"
          else
            echo "ARGOCD_URL=${{ env.ARGOCD_EXTERNAL_URL }}" >> $GITHUB_ENV
            export ARGOCD_URL="${{ env.ARGOCD_EXTERNAL_URL }}"
          fi
          
          # Export environment variables for Python scripts
          export ARGOCD_AUTH_TOKEN="${{ env.ARGOCD_AUTH_TOKEN }}"
          export ARGOCD_VERIFY_SSL=false
          
          echo "üìã ArgoCD Configuration for Python scripts:"
          echo "  Server: $ARGOCD_URL"
          echo "  Verify SSL: false"
          echo "  Token: $([ -n "${{ env.ARGOCD_AUTH_TOKEN }}" ] && echo "Available" || echo "Not available")"
      - name: Debug - Check Service Files
        run: |
          echo "üîç Checking ArgoCD service files..."
          echo "üìÅ Working directory: $(pwd)"
          
          echo "üìÇ terraform-vars structure:"
          find terraform-vars -type f -name "*.yaml" | head -20
          
          echo ""
          echo "üìÇ ArgoCD configs directory:"
          ls -la terraform-vars/manifests/argocd-configs/ 2>/dev/null || echo "Directory not found"
          
          echo ""
          echo "üìÇ Individual service directories:"
          for dir in projects repositories applications; do
            if [ -d "terraform-vars/manifests/argocd-configs/$dir" ]; then
              echo "  $dir/:"
              ls -la terraform-vars/manifests/argocd-configs/$dir/
            else
              echo "  $dir/: Directory not found"
            fi
          done
      - name: Run ArgoCD ${{ env.SERVICE }} Script
        run: |
          echo "üöÄ Running ArgoCD ${{ env.SERVICE }} script..."
          
          # Check if the specific service YAML file exists
          SERVICE_FILE="terraform-vars/manifests/argocd-configs/${{ env.SERVICE }}.yaml"
          if [ ! -f "$SERVICE_FILE" ]; then
            echo "‚ùå Service file not found: $SERVICE_FILE"
            echo "üìÇ Available YAML files:"
            find terraform-vars/manifests/argocd-configs/ -name "*.yaml" -type f 2>/dev/null || echo "No YAML files found"
            echo ""
            echo "üìÇ All files in argocd-configs:"
            ls -la terraform-vars/manifests/argocd-configs/ 2>/dev/null || echo "Directory not found"
            exit 1
          fi
          
          echo "‚úÖ Found service file: $SERVICE_FILE"
          echo "üìÑ File preview:"
          head -10 "$SERVICE_FILE"
          echo ""
          
          # Set environment variables for Python script
          if [ "${{ env.ARGOCD_SERVER }}" = "localhost:8080" ]; then
            export ARGOCD_URL="http://localhost:8080"
          else
            export ARGOCD_URL="${{ env.ARGOCD_EXTERNAL_URL }}"
          fi
          export ARGOCD_AUTH_TOKEN="${{ env.ARGOCD_AUTH_TOKEN }}"
          export ARGOCD_VERIFY_SSL=false
          
          echo "üéØ Executing ArgoCD script with environment:"
          echo "  ARGOCD_URL: $ARGOCD_URL"
          echo "  ARGOCD_VERIFY_SSL: $ARGOCD_VERIFY_SSL"
          echo "  Script: scripts/argocd-${{ env.SERVICE }}.py"
          
          python scripts/argocd-${{ env.SERVICE }}.py -f "$SERVICE_FILE"
          
          echo "‚úÖ ArgoCD ${{ env.SERVICE }} script completed successfully"
      - name: Verify ArgoCD Resources
        run: |
          echo "üîç Verifying ArgoCD resources..."
          
          case "${{ env.SERVICE }}" in
            "project")
              echo "üìã Listing ArgoCD projects:"
              argocd proj list ${{ env.ARGOCD_OPTS }} 2>/dev/null || echo "Could not list projects"
              ;;
            "repository")
              echo "üìã Listing ArgoCD repositories:"
              argocd repo list ${{ env.ARGOCD_OPTS }} 2>/dev/null || echo "Could not list repositories"
              ;;
            "application")
              echo "üìã Listing ArgoCD applications:"
              argocd app list ${{ env.ARGOCD_OPTS }} 2>/dev/null || echo "Could not list applications"
              ;;
          esac
          
          echo "‚úÖ Verification completed"
      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          
          # Kill port-forward process if it was started
          if [ -n "${{ env.PORT_FORWARD_PID }}" ]; then
            echo "Stopping port-forward process..."
            kill ${{ env.PORT_FORWARD_PID }} 2>/dev/null || true
          fi
          
          # Kill any remaining kubectl port-forward processes
          pkill -f "kubectl port-forward" 2>/dev/null || true
          
          echo "‚úÖ Cleanup completed"
